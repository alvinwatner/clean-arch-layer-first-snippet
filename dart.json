{
	// Place your snippets for dart here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	"Datasource Abstract Function": {
		"prefix": "dsa",
		"body": [
			"Future<${1:model}> ${2:usecase}(${3: argument});"
		],
		"description": "Write a function for datasource abstract"
	},
	"Datasource Function Implementation": {
		"prefix": "implds",
		"body": [
			"final String path = '\\$baseUrl/${1:baseUrl}';",
			"final Response<dynamic> response = await dio.post(",
			"path,",
			"data: <String, dynamic>{",
			"'${3:arg1}': ${4:arg1},",
			"'${5:arg2}': ${6:arg2},",
			"},",
			");",
			"if (response.statusCode == 200) {",
			"return ${2:model}.fromJson(response.data);",
			"} else {",
			"throw DioError(",
			"requestOptions: RequestOptions(path: path),",
			");",
			"}"
		],
		"description": "Write data source implementation"
	},
	"Repository Abstract Function": {
		"prefix": "repoa",
		"body": [
			"Future<Either<Failure, ${1:model}>> ${2:usecase}(${3:arg});",
		],
		"description": "Write a function for repo abstract"
	},
	"Repository Implementation": {
		"prefix": "implrepo",
		"body": [
			"bool isConnected = await networkInfo.isConnected;",
			"if (isConnected) {",
			"try {",
			"final ${1:model} response = await remoteDataSource.${2:usecase}(",
			"arg1,",
			"arg2,",
			");",
			"return Right(response);",
			"} on DioError catch (error) {",
			"if (error.response == null) {",
			"return Left(",
			"ServerFailure(",
			"DataApiFailure(message: error.message),",
			"),",
			");",
			"}",
			"final errorResponseData = error.response?.data;",
			"dynamic errorData;",
			"String errorMessage = getErrorMessageFromEndpoint(",
			"errorResponseData,",
			"error.message,",
			"error.response?.statusCode ?? 400,",
			");",
			"if (errorResponseData is Map &&",
			"errorResponseData.containsKey('errors')) {",
			"errorData = errorResponseData['errors'];",
			"}",
			"return Left(",
			"ServerFailure(",
			"DataApiFailure(",
			"message: errorMessage,",
			"statusCode: error.response?.statusCode,",
			"httpMessage: error.message,",
			"errorData: errorData,",
			"),",
			"),",
			");",
			"} on TypeError catch (error) {",
			"return Left(ParsingFailure(error.toString()));",
			"}",
			"} else {",
			"return Left(ConnectionFailure());",
			"}"
		],
		"description": "Write an implementation function for  a repository"
	},
	"Bloc Event Function": {
		"prefix": "eventblocfunc",
		"body": [
			"on<${1:bloc}${2:event}>(_on${2:event});"
		],
		"description": "Write a bloc event"
	},	
	"Bloc Event Function Implementation": {
		"prefix": "eventblocfuncimpl",
		"body": [
			"FutureOr<void> _on${1:eventfunc}(",
			"${2:event}Event event,",
			"Emitter<${2:bloc}State> emit,",
			") async {",
			"emit(${2:bloc}InitialState());",
			"",
			"final coolResult = await ${3:usecase}(Params${4:paramUsecase}(",
			"arg1: event.arg1,",
			"arg2: event.arg2,",
			"));",
			"",
			"emit(",
			"coolResult.fold(",
			"(failure) {",
			"var errorMessage = '';",
			"if (failure is ServerFailure) {",
			"errorMessage = failure.dataApiFailure.message ?? errorMessage;",
			"} else if (failure is ConnectionFailure) {",
			"errorMessage = failure.errorMessage;",
			"} else if (failure is ParsingFailure) {",
			"errorMessage = failure.errorMessage;",
			"}",
			"return ${2:failure_state}(",
			"errorMessage: errorMessage,",
			");",
			"},",
			"(response) => ${2:success_state}(",
			"successResponse: response,",
			"),",
			"),",
			");",
			"}"
		],
		"description": "Write a bloc state with zero property"
	},	
	"Bloc Event Class": {
		"prefix": "eventclass",
		"body": [
			"class ${1:event} extends ${2:eventAbstract} {",
			"final ${3:property};",
			"",
			"const ${1:event}({",
			"this.arg1,",
			"});",
			"",
			"@override",
			"List<Object?> get props => [arg1];",
			"",
			"@override",
			"String toString() {",
			"return '${1:event}{arg1: $arg1}';",
			"}",
			"}",
		],
		"description": "Write a bloc event"
	},
	"Bloc State Class Failure": {
		"prefix": "stateclassfailur",
		"body": [
			"class ${1:bloc}${2:state}State extends ${1:bloc}State {",
			"final String errorMessage;",
			"",
			"const ${1:bloc}${2:state}State({required this.errorMessage,});",
			"",
			"@override",
			"List<Object> get props => [errorMessage];",
			"",		  
			"@override",
			"String toString() {",
			"",
			"return '${1:bloc}${2:state}State{errorMessage: \\$errorMessage}';",
			"}",
			"",
			"}",
		],
		"description": "Write a bloc state with one property"
	},	
	"Bloc State Class 1 Property": {
		"prefix": "stateclass",
		"body": [
			"class ${1:bloc}${2:state}State extends ${1:bloc}State {",
			"final Arg1 arg1;",
			"",
			"const ${1:bloc}${2:state}State({required this.arg1});",
			"",
			"@override",
			"List<Object> get props => [arg1];",
			"",		  
			"@override",
			"String toString() {",
			"",
			"return '${1:bloc}${2:state}State{arg1: $arg1}';",
			"}",
			"",
			"}",
		],
		"description": "Write a bloc state with one property"
	},
	"Bloc State Class": {
		"prefix": "state",
		"body": [
			"class CoolLoadingState extends CoolState {}",
		],
		"description": "Write a bloc state with zero property"
	},
	"Model": {
		"prefix": "mdl",
		"body": [
			"@JsonSerializable(",
			"explicitToJson: true,",
			")",
			"class ${1:model} extends Equatable {",
			"@JsonKey(name: 'message')",
			"  final String? message;",
			"  @JsonKey(name: 'data')",
			"  final dynamic data;",
			"",
			"  const ${1:model}({",
			"    this.message,",
			"    this.data,",
			"  });",
			"",
			"  static ${1:model} fromJson(Map<String, dynamic> json) =>",
			"      _$${1:model}FromJson(json);",
			"",
			"  Map<String?, dynamic> toJson() => _$${1:model}ToJson(this);",
			"",
			"  @override",
			"  List<Object?> get props => [",
			"        message,",
			"        data,",
			"      ];",
			"",
			"  @override",
			"  String toString() {",
			"    return '${1:model}{message: $message, data: $data}';",
			"  }",
			"}",
		],
		"description": "Write a model for build runnner with Json annotation"
	},
	"Test Datasource": {
		"prefix": "tstds",
		"body": [
			"group('${1:usecase}', () {",
			"final jsonMap = json.decode(fixture('login_response.json'));",
			"final tResponse = ${2:model}.fromJson(jsonMap);",
			"",
			"void setUpMockDioSuccess() {",
			"final responsePayload = jsonMap;",
			"final response = Response(",
			"requestOptions: tRequestOptions,",
			"data: responsePayload,",
			"statusCode: 200,",
			"headers: Headers.fromMap({",
			"Headers.contentTypeHeader: [Headers.jsonContentType",
			"],",
			"}),",
			");",
			"when(mockDio.post(",
			"any,",
			"data: anyNamed('data'),",
			"options: anyNamed('options'),",
			")).thenAnswer((_) async => response);",
			"}",
			"",
			"test(",
			"'make sure ${1:usecase} called with method POST',",
			"() async {",
			"// arrange",
			"setUpMockDioSuccess();",
			"",
			"// act",
			"await remoteDataSource.${1:usecase}(",
			"'',",
			"'',",
			"'',",
			"'',",
			");",
			"",
			"// assert",
			"verify(",
			"mockDio.post(",
			"'$baseUrl/v2/[TYPE YOUR ENDPOINT]',",
			"data: {",
			"'email': '',",
			"'lat': '',",
			"'lng': '',",
			"'notif_token': '',",
			"},",
			"options: anyNamed('options'),",
			"),",
			");",
			"},",
			");",
			"",
			"test(",
			"'make sure returns ${2:model} when response is (200) from endpoint',",
			"() async {",
			"// arrange",
			"setUpMockDioSuccess();",
			"",
			"// act",
			"final result = await remoteDataSource.${1:usecase}(",
			"'',",
			"'',",
			"'',",
			"'',",
			");",
			"",
			"// assert",
			"expect(result, tResponse);",
			"},",
			");",
			"",
			"test(",
			"'make sure throw exception DioError when returns exception from endpoint',",
			"() async {",
			"// arrange",
			"final response = Response(",
			"requestOptions: tRequestOptions,",
			"data: 'Bad Request',",
			"statusCode: 400,",
			");",
			"when(",
			"mockDio.post(",
			"any,",
			"data: anyNamed('data'),",
			"options: anyNamed('options'),",
			"),",
			").thenAnswer((_) async => response);",
			"",
			"// act",
			"final call = remoteDataSource.${1:usecase}(",
			"'',",
			"'',",
			"'',",
			"'',",
			");",
			"",
			"// assert",
			"expect(() => call, throwsA(const TypeMatcher<DioError>()));",
			"},",
			");",
			"});",
		],
		"description": "Write a set of unit testing for datasource usecase"
	},
	"Test Model": {
		"prefix": "tsmdl",
		"body": [
			"group('${1:model}', () {",
			"final tModel = ${1:model}.fromJson(jsonData);",
			"",
			"test(",
			"'make sure props value',",
			"() async {",
			"// assert",
			"expect(",
			"tModel.props,",
			"[",
			"tModel.message,",
			"tModel.data,",
			"],",
			");",
			"},",
			");",
			"",
			"test(",
			"'make sure toString output',",
			"() async {",
			"// assert",
			"expect(",
			"tModel.toString(),",
			"'${1:model}{message: ${tModel.message}, data: ${tModel.data}}',",
			");",
			"},",
			");",
			"",
			"test(",
			"'make sure fromJson function return ListVacancies',",
			"() async {",
			"// act",
			"final actualModel = ${1:model}.fromJson(jsonData);",
			"",
			"// assert",
			"expect(actualModel, tModel);",
			"},",
			");",
			"",
			"test(",
			"'make sure toJson function return Map object',",
			"() async {",
			"// arrange",
			"final model = ${1:model}.fromJson(jsonData);",
			"",
			"// act",
			"final actualMap = json.encode(model.toJson());",
			"",
			"// assert",
			"expect(actualMap, json.encode(tModel.toJson()));",
			"},",
			");",
			"});",
		],
		"description": "Write a unit test for a model"
	},
	"Test Repository Implementation": {
		"prefix": "tsimplrepo",
		"body": [
			"group('${1:usecase}', () {",
			"const tResponse = ${2:model}();",
			"",
			"test(",
			"'make sure return success value when receieve success response from endpoint',",
			"() async {",
			"// arrange",
			"setUpMockNetworkConnected();",
			"when(mockRemoteDataSource.${1:usecase}(",
			"any,",
			"any,",
			"any,",
			"any,",
			")).thenAnswer((_) async => tResponse);",
			"",
			"// act",
			"final result = await repositoryImpl.${1:usecase}('', '', '', '');",
			"",
			"// assert",
			"verify(mockRemoteDataSource.${1:usecase}(any, any, any, any));",
			"expect(result, const Right(tResponse));",
			"},",
			");",
			"",
			"test(",
			"'make sure return ServerFailure when response is timeout',",
			"() async {",
			"// arrange",
			"setUpMockNetworkConnected();",
			"when(mockRemoteDataSource.${1:usecase}(any, any, any, any))",
			".thenThrow(DioError(",
			"requestOptions: tRequestOptions,",
			"error: 'testError',",
			"));",
			"",
			"// act",
			"final result = await repositoryImpl.${1:usecase}('', '', '', '');",
			"",
			"// assert",
			"verify(mockRemoteDataSource.${1:usecase}(any, any, any, any));",
			"expect(",
			"result,",
			"Left(ServerFailure(const DataApiFailure(",
			"message: 'testError',",
			"))));",
			"},",
			");",
			"",
			"test(",
			"'make sure return ServerFailure when failed response from endpoint',",
			"() async {",
			"// arrange",
			"setUpMockNetworkConnected();",
			"when(mockRemoteDataSource.${1:usecase}(any, any, any, any))",
			".thenThrow(",
			"DioError(",
			"requestOptions: tRequestOptions,",
			"error: 'testError',",
			"response: Response(",
			"requestOptions: tRequestOptions,",
			"data: {",
			"'title': 'testTitleError',",
			"'message': 'testMessageError',",
			"'errors': {'testError': []},",
			"},",
			"statusCode: 400,",
			"),",
			"),",
			");",
			"",
			"// act",
			"final result = await repositoryImpl.${1:usecase}('', '', '', '');",
			"",
			"// assert",
			"verify(mockRemoteDataSource.${1:usecase}(any, any, any, any));",
			"expect(",
			"result,",
			"Left(ServerFailure(const DataApiFailure(",
			"statusCode: 400,",
			"httpMessage: 'testError',",
			"message: 'status code : 400 | error: testMessageError',",
			"errorData: {'testError': []},",
			"))));",
			"},",
			");",
			"",
			"testServerFailureString(",
			"() => mockRemoteDataSource.${1:usecase}(any, any, any, any),",
			"() => repositoryImpl.${1:usecase}('', '', '', ''),",
			"() => mockRemoteDataSource.${1:usecase}('', '', '', ''),",
			");",
			"",
			"testParsingFailure(",
			"() => mockRemoteDataSource.${1:usecase}(any, any, any, any),",
			"() => repositoryImpl.${1:usecase}('', '', '', ''),",
			"() => mockRemoteDataSource.${1:usecase}('', '', '', ''),",
			");",
			"",
			"testDisconnected(() => repositoryImpl.${1:usecase}('', '', '', ''));",
			"});",
		],
		"description": "Write a unit test for a model"
	},
}